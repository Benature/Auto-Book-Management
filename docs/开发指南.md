# 豆瓣书单同步与 Calibre 集成自动化 - 开发指南

## 开发环境搭建

### 系统要求

- **操作系统**：Windows 10/11、macOS 或 Linux
- **Python 版本**：3.8 或更高版本
- **Calibre**：5.0 或更高版本，并启用 Content Server
- **数据库**：SQLite（开发环境）/ PostgreSQL（可选，生产环境）
- **IDE**：推荐 VSCode 或 PyCharm

### 环境准备

1. **克隆项目**

   ```bash
   git clone <repository-url>
   cd 豆瓣zlib
   ```

2. **创建虚拟环境**

   ```bash
   # 使用 venv
   python -m venv venv
   
   # 激活虚拟环境
   # Windows
   venv\Scripts\activate
   # macOS/Linux
   source venv/bin/activate
   ```

3. **安装依赖**

   ```bash
   pip install -r requirements.txt
   ```

4. **配置文件设置**

   复制 `config.yaml.example` 到 `config.yaml`，并填写相关配置：

   ```bash
   cp config.yaml.example config.yaml
   # 编辑 config.yaml 填写配置信息
   ```

5. **初始化数据库**

   ```bash
   # 使用项目提供的初始化脚本
   python -c "from db.database import Database; db = Database('sqlite:///data/douban_books.db'); db.init_db()"
   ```

6. **启动 Calibre Content Server**

   ```bash
   # 启动 Calibre Content Server，替换路径为你的书库路径
   calibre-server --port=8080 --username=your_username --password=your_password /path/to/your/calibre/library
   ```

## 项目结构说明

项目采用模块化设计，各模块职责明确，便于开发和维护：

```
豆瓣zlib/
├── config/           # 配置管理
├── data/             # 数据存储
├── db/               # 数据库模型和操作
├── scrapers/         # 爬虫模块
├── services/         # 服务模块
├── scheduler/        # 调度系统
├── utils/            # 工具函数
├── tests/            # 测试代码
├── logs/             # 日志文件
├── migrations/       # 数据库迁移脚本
├── main.py           # 主程序入口
└── config.yaml       # 配置文件
```

## 开发规范

### 代码风格

项目遵循 [PEP 8](https://www.python.org/dev/peps/pep-0008/) 编码规范，使用 flake8 和 pylint 进行代码质量检查：

```bash
# 安装代码检查工具
pip install flake8 pylint

# 运行检查
flake8 .
pylint --recursive=y .
```

主要规范要点：

1. **命名规范**
   - 类名：使用 CamelCase（如 `DoubanScraper`）
   - 函数和变量：使用 snake_case（如 `get_book_info`）
   - 常量：使用全大写 SNAKE_CASE（如 `MAX_RETRY_COUNT`）

2. **文档注释**
   - 所有模块、类和函数都应有文档字符串
   - 使用 Google 风格的文档注释

   ```python
   def function_name(param1, param2):
       """函数简短描述。
       
       详细描述（可选）。
       
       Args:
           param1: 参数1的描述
           param2: 参数2的描述
           
       Returns:
           返回值描述
           
       Raises:
           ExceptionType: 异常情况描述
       """
       # 函数实现
   ```

3. **导入顺序**
   - 标准库导入
   - 相关第三方导入
   - 本地应用/库特定导入

   ```python
   # 标准库
   import os
   import sys
   from datetime import datetime
   
   # 第三方库
   import requests
   from bs4 import BeautifulSoup
   
   # 本地模块
   from db.models import DoubanBook
   from utils.logger import get_logger
   ```

4. **错误处理**
   - 使用明确的异常类型
   - 提供有意义的错误消息
   - 适当记录异常信息

   ```python
   try:
       # 可能引发异常的代码
   except RequestException as e:
       logger.error(f"网络请求失败: {e}")
       raise ConnectionError(f"无法连接到豆瓣: {e}") from e
   ```

### 日志规范

使用项目提供的日志工具，确保日志信息清晰有用：

```python
from utils.logger import get_logger

logger = get_logger(__name__)

# 使用不同级别的日志
logger.debug("详细调试信息")
logger.info("一般信息")
logger.warning("警告信息")
logger.error("错误信息")
logger.critical("严重错误信息")
```

### 测试规范

项目使用 pytest 进行测试，测试文件应放在 `tests/` 目录下：

```python
# tests/test_douban_scraper.py
import pytest
from scrapers.douban_scraper import DoubanScraper

def test_parse_book_info():
    # 测试代码
    scraper = DoubanScraper("test_cookie")
    html = "<html>测试HTML</html>"
    result = scraper.parse_book_info(html)
    assert "title" in result
    assert "author" in result
```

运行测试：

```bash
# 运行所有测试
pytest

# 运行特定测试文件
pytest tests/test_douban_scraper.py

# 带覆盖率报告
pytest --cov=. tests/
```

## 模块开发指南

### 1. 配置管理模块

**文件**：`config/config_manager.py`

**职责**：加载和验证配置文件，提供配置访问接口。

**实现要点**：
- 使用 PyYAML 解析 YAML 配置文件
- 实现配置验证逻辑，确保必要字段存在
- 提供获取各模块配置的方法

**示例代码**：

```python
import yaml
from pathlib import Path

class ConfigManager:
    def __init__(self, config_path):
        self.config_path = Path(config_path)
        self.config = self._load_config()
        self._validate_config()
    
    def _load_config(self):
        """加载配置文件。"""
        try:
            with open(self.config_path, 'r', encoding='utf-8') as f:
                return yaml.safe_load(f)
        except Exception as e:
            raise ValueError(f"无法加载配置文件: {e}") from e
    
    def _validate_config(self):
        """验证配置文件。"""
        required_sections = ['douban', 'database', 'calibre', 'zlibrary', 'schedule', 'lark']
        for section in required_sections:
            if section not in self.config:
                raise ValueError(f"配置文件缺少必要的 '{section}' 部分")
        
        # 验证各部分的必要字段
        if 'cookie' not in self.config['douban']:
            raise ValueError("配置文件缺少 'douban.cookie' 字段")
        # 其他验证...
    
    def get_douban_config(self):
        """获取豆瓣相关配置。"""
        return self.config['douban']
    
    def get_database_url(self):
        """获取数据库连接 URL。"""
        db_config = self.config['database']
        if db_config['type'] == 'sqlite':
            return f"sqlite:///{db_config['path']}"
        elif db_config['type'] == 'postgresql':
            return f"postgresql://{db_config['username']}:{db_config['password']}@{db_config['host']}:{db_config['port']}/{db_config['dbname']}"
        else:
            raise ValueError(f"不支持的数据库类型: {db_config['type']}")
    
    # 其他配置获取方法...
```

### 2. 数据库模块

**文件**：`db/models.py` 和 `db/database.py`

**职责**：定义数据模型，提供数据库操作接口。

**实现要点**：
- 使用 SQLAlchemy ORM 定义数据模型
- 实现数据库连接和会话管理
- 提供 CRUD 操作接口

**示例代码**：

```python
# db/models.py
from sqlalchemy import Column, Integer, String, DateTime, Text
from sqlalchemy.ext.declarative import declarative_base
from datetime import datetime

Base = declarative_base()

class DoubanBook(Base):
    """豆瓣书籍数据模型。"""
    __tablename__ = 'douban_books'
    
    id = Column(Integer, primary_key=True)
    title = Column(String(255), nullable=False)
    author = Column(String(255))
    douban_url = Column(String(255), unique=True)
    status = Column(String(50))  # new/matched/downloaded/uploaded
    created_at = Column(DateTime, default=datetime.now)
    
    def __repr__(self):
        return f"<DoubanBook(title='{self.title}', author='{self.author}')>"

# db/database.py
from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker, scoped_session
from contextlib import contextmanager
from .models import Base, DoubanBook
from utils.logger import get_logger

logger = get_logger(__name__)

class Database:
    def __init__(self, db_url):
        self.engine = create_engine(db_url)
        self.Session = scoped_session(sessionmaker(bind=self.engine))
    
    def init_db(self):
        """初始化数据库。"""
        logger.info("初始化数据库...")
        Base.metadata.create_all(self.engine)
        logger.info("数据库初始化完成")
    
    @contextmanager
    def session_scope(self):
        """提供事务会话上下文。"""
        session = self.Session()
        try:
            yield session
            session.commit()
        except Exception as e:
            session.rollback()
            logger.error(f"数据库操作失败: {e}")
            raise
        finally:
            session.close()
    
    def add_book(self, title, author, douban_url):
        """添加书籍记录。"""
        with self.session_scope() as session:
            # 检查是否已存在
            existing = session.query(DoubanBook).filter_by(douban_url=douban_url).first()
            if existing:
                logger.info(f"书籍已存在: {title}")
                return existing
            
            # 创建新记录
            book = DoubanBook(
                title=title,
                author=author,
                douban_url=douban_url,
                status="new"
            )
            session.add(book)
            logger.info(f"添加新书籍: {title}")
            return book
    
    def update_book_status(self, book_id, status):
        """更新书籍状态。"""
        with self.session_scope() as session:
            book = session.query(DoubanBook).filter_by(id=book_id).first()
            if not book:
                logger.warning(f"未找到书籍 ID: {book_id}")
                return False
            
            book.status = status
            logger.info(f"更新书籍状态: {book.title} -> {status}")
            return True
    
    def get_books_by_status(self, status):
        """获取指定状态的书籍。"""
        with self.session_scope() as session:
            books = session.query(DoubanBook).filter_by(status=status).all()
            return books
    
    # 其他数据库操作方法...
```

### 3. 豆瓣爬虫模块

**文件**：`scrapers/douban_scraper.py`

**职责**：爬取豆瓣「想读」书单，解析书籍信息。

**实现要点**：
- 使用 requests 和 BeautifulSoup 进行网页爬取和解析
- 处理分页和异常情况
- 实现重试机制

**示例代码**：

```python
import requests
from bs4 import BeautifulSoup
import time
from requests.exceptions import RequestException
from utils.logger import get_logger

logger = get_logger(__name__)

class DoubanScraper:
    def __init__(self, cookie):
        self.cookie = cookie
        self.headers = {
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36',
            'Cookie': cookie
        }
        self.base_url = "https://book.douban.com/people/me/wish"
        self.max_retries = 3
        self.retry_delay = 2  # 秒
    
    def _make_request(self, url):
        """发送 HTTP 请求，带重试机制。"""
        for attempt in range(self.max_retries):
            try:
                response = requests.get(url, headers=self.headers, timeout=10)
                response.raise_for_status()
                return response
            except RequestException as e:
                logger.warning(f"请求失败 (尝试 {attempt+1}/{self.max_retries}): {e}")
                if attempt < self.max_retries - 1:
                    time.sleep(self.retry_delay)
                else:
                    logger.error(f"请求失败，已达最大重试次数: {url}")
                    raise
    
    def get_wish_list(self):
        """获取「想读」书单。"""
        all_books = []
        page = 0
        has_next = True
        
        while has_next:
            page += 1
            url = f"{self.base_url}?start={(page-1)*15}&sort=time&rating=all&filter=all&mode=grid"
            logger.info(f"爬取第 {page} 页: {url}")
            
            try:
                response = self._make_request(url)
                soup = BeautifulSoup(response.text, 'html.parser')
                
                # 解析书籍列表
                book_items = soup.select('.subject-item')
                if not book_items:
                    logger.warning(f"第 {page} 页未找到书籍，可能是页面结构变化或已到达末页")
                    break
                
                for item in book_items:
                    book_info = self.parse_book_info(item)
                    if book_info:
                        all_books.append(book_info)
                
                # 检查是否有下一页
                next_link = soup.select_one('.paginator .next a')
                has_next = next_link is not None
                
                # 防止请求过快
                time.sleep(1)
                
            except Exception as e:
                logger.error(f"爬取第 {page} 页时出错: {e}")
                break
        
        logger.info(f"共爬取 {len(all_books)} 本书")
        return all_books
    
    def parse_book_info(self, item):
        """解析书籍信息。"""
        try:
            # 提取书名
            title_elem = item.select_one('.title a')
            if not title_elem:
                return None
            
            title = title_elem.text.strip()
            douban_url = title_elem['href']
            
            # 提取作者
            pub_info = item.select_one('.pub')
            author = "未知"
            if pub_info:
                pub_text = pub_info.text.strip()
                parts = pub_text.split('/')
                if len(parts) > 0:
                    author = parts[0].strip()
            
            return {
                'title': title,
                'author': author,
                'douban_url': douban_url
            }
        except Exception as e:
            logger.error(f"解析书籍信息失败: {e}")
            return None
    
    def run(self):
        """执行爬虫任务。"""
        logger.info("开始爬取豆瓣「想读」书单")
        try:
            books = self.get_wish_list()
            logger.info(f"爬取完成，共获取 {len(books)} 本书")
            return books
        except Exception as e:
            logger.error(f"爬取过程中发生错误: {e}")
            raise
```

### 4. Calibre 查询模块

**文件**：`services/calibre_service.py`

**职责**：查询 Calibre 书库，判断书籍是否已收录。

**实现要点**：
- 调用 Calibre Content Server API
- 实现模糊匹配算法
- 处理认证和异常情况

**示例代码**：

```python
import requests
from requests.auth import HTTPBasicAuth
import re
from difflib import SequenceMatcher
from utils.logger import get_logger

logger = get_logger(__name__)

class CalibreService:
    def __init__(self, server_url, username, password):
        self.server_url = server_url.rstrip('/')
        self.username = username
        self.password = password
        self.auth = HTTPBasicAuth(username, password)
        self.session = requests.Session()
    
    def _make_request(self, endpoint, method='get', **kwargs):
        """发送请求到 Calibre Content Server。"""
        url = f"{self.server_url}/{endpoint}"
        try:
            if method.lower() == 'get':
                response = self.session.get(url, auth=self.auth, **kwargs)
            elif method.lower() == 'post':
                response = self.session.post(url, auth=self.auth, **kwargs)
            else:
                raise ValueError(f"不支持的 HTTP 方法: {method}")
            
            response.raise_for_status()
            return response
        except requests.exceptions.RequestException as e:
            logger.error(f"Calibre 服务器请求失败: {e}")
            raise
    
    def search_book(self, title, author):
        """搜索书籍。"""
        logger.info(f"在 Calibre 中搜索: {title} - {author}")
        
        # 构建搜索查询
        # 先尝试精确匹配
        query = f"title:~\"{title}\" author:~\"{author}\""
        try:
            response = self._make_request(f"ajax/search?query={query}")
            results = response.json()
            
            if results['total_num'] > 0:
                logger.info(f"找到精确匹配结果: {results['total_num']} 本")
                return results['book_ids']
            
            # 如果精确匹配没有结果，尝试更宽松的搜索
            logger.info("精确匹配未找到结果，尝试模糊搜索")
            title_terms = re.sub(r'[^\w\s]', '', title).split()
            query = " or ".join([f"title:~\"{term}\"" for term in title_terms])
            
            if author:
                author_terms = re.sub(r'[^\w\s]', '', author).split()
                author_query = " or ".join([f"author:~\"{term}\"" for term in author_terms])
                query = f"({query}) and ({author_query})"
            
            response = self._make_request(f"ajax/search?query={query}")
            results = response.json()
            
            if results['total_num'] > 0:
                logger.info(f"找到模糊匹配结果: {results['total_num']} 本")
                # 获取候选书籍的详细信息
                candidates = []
                for book_id in results['book_ids']:
                    book_data = self._get_book_data(book_id)
                    if book_data:
                        candidates.append(book_data)
                
                # 使用模糊匹配找出最佳匹配
                best_match = self._fuzzy_match(title, author, candidates)
                if best_match:
                    logger.info(f"最佳匹配: {best_match['title']} - {best_match['authors']}")
                    return [best_match['id']]
            
            logger.info("未找到匹配的书籍")
            return []
            
        except Exception as e:
            logger.error(f"搜索书籍时出错: {e}")
            return []
    
    def _get_book_data(self, book_id):
        """获取书籍详细信息。"""
        try:
            response = self._make_request(f"ajax/book/{book_id}")
            return response.json()
        except Exception as e:
            logger.error(f"获取书籍数据失败 (ID: {book_id}): {e}")
            return None
    
    def _fuzzy_match(self, title, author, candidates):
        """模糊匹配算法。"""
        best_score = 0
        best_match = None
        
        for book in candidates:
            # 计算标题相似度
            title_score = SequenceMatcher(None, title.lower(), book['title'].lower()).ratio()
            
            # 计算作者相似度
            author_score = 0
            if author and 'authors' in book and book['authors']:
                # 尝试不同的作者名格式（姓名顺序可能不同）
                author_variants = [author, ' '.join(reversed(author.split()))]
                for variant in author_variants:
                    for book_author in book['authors']:
                        score = SequenceMatcher(None, variant.lower(), book_author.lower()).ratio()
                        author_score = max(author_score, score)
            
            # 综合评分（标题权重更高）
            combined_score = title_score * 0.7 + author_score * 0.3
            
            if combined_score > best_score:
                best_score = combined_score
                best_match = book
        
        # 设置匹配阈值
        if best_score >= 0.6:
            return best_match
        return None
    
    def upload_book(self, file_path, metadata=None):
        """上传书籍到 Calibre。"""
        logger.info(f"上传书籍: {file_path}")
        try:
            with open(file_path, 'rb') as f:
                files = {'file': f}
                data = {}
                if metadata:
                    data['title'] = metadata.get('title', '')
                    data['authors'] = metadata.get('author', '')
                
                response = self._make_request('cdb/add-book', method='post', files=files, data=data)
                result = response.json()
                
                if 'book_id' in result:
                    logger.info(f"上传成功，书籍 ID: {result['book_id']}")
                    return result['book_id']
                else:
                    logger.error(f"上传失败: {result.get('error', '未知错误')}")
                    return None
        except Exception as e:
            logger.error(f"上传书籍时出错: {e}")
            return None
```

### 5. Z-Library 下载模块

**文件**：`services/zlibrary_service.py`

**职责**：从 Z-Library 搜索和下载书籍。

**实现要点**：
- 使用 zlibrary 包进行 API 调用
- 实现格式优先级选择
- 处理下载限制和异常情况

**示例代码**：

```python
import os
import time
from pathlib import Path
from zlibrary import ZLibrary
from utils.logger import get_logger

logger = get_logger(__name__)

class ZLibraryService:
    def __init__(self, username, password, format_priority):
        self.username = username
        self.password = password
        self.format_priority = format_priority
        self.client = None
        self.max_retries = 3
        self.retry_delay = 5  # 秒
    
    def _ensure_client(self):
        """确保客户端已初始化并登录。"""
        if self.client is None:
            logger.info(f"初始化 Z-Library 客户端并登录: {self.username}")
            try:
                self.client = ZLibrary()
                self.client.login(self.username, self.password)
                logger.info("Z-Library 登录成功")
            except Exception as e:
                logger.error(f"Z-Library 登录失败: {e}")
                raise
    
    def search_book(self, title, author):
        """搜索书籍。"""
        self._ensure_client()
        search_query = f"{title} {author}".strip()
        logger.info(f"在 Z-Library 搜索: {search_query}")
        
        for attempt in range(self.max_retries):
            try:
                results = self.client.search(search_query)
                if not results:
                    logger.info(f"未找到匹配的书籍: {search_query}")
                    return None
                
                logger.info(f"找到 {len(results)} 个搜索结果")
                
                # 选择最佳匹配结果
                best_match = self._select_best_match(results, title, author)
                if best_match:
                    logger.info(f"最佳匹配: {best_match['title']} - {best_match['author']}")
                    return best_match
                
                logger.info("未找到合适的匹配")
                return None
                
            except Exception as e:
                logger.warning(f"搜索失败 (尝试 {attempt+1}/{self.max_retries}): {e}")
                if attempt < self.max_retries - 1:
                    time.sleep(self.retry_delay)
                else:
                    logger.error(f"搜索失败，已达最大重试次数: {e}")
                    raise
    
    def _select_best_match(self, results, title, author):
        """从搜索结果中选择最佳匹配。"""
        # 简单实现：选择第一个结果
        # 实际应用中应该实现更复杂的匹配算法
        if results:
            return results[0]
        return None
    
    def download_book(self, book_id, output_dir):
        """下载书籍。"""
        self._ensure_client()
        logger.info(f"准备下载书籍 ID: {book_id}")
        
        # 确保输出目录存在
        output_path = Path(output_dir)
        output_path.mkdir(parents=True, exist_ok=True)
        
        for attempt in range(self.max_retries):
            try:
                # 获取书籍详情
                book_info = self.client.get_book(book_id)
                if not book_info:
                    logger.error(f"无法获取书籍信息: {book_id}")
                    return None
                
                # 选择最佳格式
                available_formats = book_info.get('formats', [])
                best_format = self.select_best_format(available_formats)
                if not best_format:
                    logger.warning(f"未找到支持的格式: {available_formats}")
                    return None
                
                # 下载书籍
                logger.info(f"下载格式: {best_format}")
                file_path = os.path.join(output_dir, f"{book_info['title']}.{best_format}".replace('/', '_'))
                
                success = self.client.download(book_id, file_path, format=best_format)
                if success:
                    logger.info(f"下载成功: {file_path}")
                    return file_path
                else:
                    logger.error("下载失败")
                    return None
                
            except Exception as e:
                logger.warning(f"下载失败 (尝试 {attempt+1}/{self.max_retries}): {e}")
                if attempt < self.max_retries - 1:
                    time.sleep(self.retry_delay)
                else:
                    logger.error(f"下载失败，已达最大重试次数: {e}")
                    raise
    
    def select_best_format(self, available_formats):
        """按优先级选择最佳格式。"""
        for format_type in self.format_priority:
            if format_type.lower() in [f.lower() for f in available_formats]:
                return format_type.lower()
        return None
```

### 6. 飞书通知模块

**文件**：`services/lark_service.py`

**职责**：通过飞书机器人发送通知消息。

**实现要点**：
- 调用飞书 Webhook API
- 格式化消息内容
- 处理发送失败情况

**示例代码**：

```python
import requests
import json
from datetime import datetime
from utils.logger import get_logger

logger = get_logger(__name__)

class LarkService:
    def __init__(self, webhook_url):
        self.webhook_url = webhook_url
    
    def send_message(self, title, content):
        """发送消息到飞书。"""
        logger.info(f"发送飞书消息: {title}")
        
        message = {
            "msg_type": "post",
            "content": {
                "post": {
                    "zh_cn": {
                        "title": title,
                        "content": [
                            [
                                {"tag": "text", "text": content}
                            ]
                        ]
                    }
                }
            }
        }
        
        try:
            response = requests.post(
                self.webhook_url,
                headers={"Content-Type": "application/json"},
                data=json.dumps(message)
            )
            response.raise_for_status()
            
            result = response.json()
            if result.get('code') == 0:
                logger.info("飞书消息发送成功")
                return True
            else:
                logger.error(f"飞书消息发送失败: {result.get('msg', '未知错误')}")
                return False
                
        except Exception as e:
            logger.error(f"发送飞书消息时出错: {e}")
            return False
    
    def format_task_report(self, stats):
        """格式化任务报告。"""
        today = datetime.now().strftime("%Y-%m-%d")
        report = f"📚 豆瓣书单同步任务完成\n\n"
        report += f"- 新增书籍：{stats.get('new', 0)} 本\n"
        report += f"- 已存在书籍：{stats.get('matched', 0)} 本\n"
        report += f"- 成功下载并上传：{stats.get('uploaded', 0)} 本\n"
        report += f"- 下载失败：{stats.get('failed', 0)} 本\n\n"
        report += f"详细日志请见本地文件 logs/task_{today}.log"
        
        return report
    
    def send_task_report(self, stats):
        """发送任务报告。"""
        title = "📚 豆瓣书单同步任务完成"
        content = self.format_task_report(stats)
        return self.send_message(title, content)
```

### 7. 调度系统

**文件**：`scheduler/task_scheduler.py`

**职责**：管理定时任务，协调各模块工作。

**实现要点**：
- 使用 APScheduler 实现定时调度
- 实现任务执行逻辑
- 处理任务失败和恢复

**示例代码**：

```python
from apscheduler.schedulers.background import BackgroundScheduler
from apscheduler.triggers.cron import CronTrigger
import tempfile
import shutil
from datetime import datetime
from utils.logger import get_logger

logger = get_logger(__name__)

class TaskScheduler:
    def __init__(self, config_manager, db, douban_scraper, calibre_service, zlibrary_service, lark_service):
        self.scheduler = BackgroundScheduler()
        self.config = config_manager
        self.db = db
        self.douban_scraper = douban_scraper
        self.calibre_service = calibre_service
        self.zlibrary_service = zlibrary_service
        self.lark_service = lark_service
        self.temp_dir = tempfile.mkdtemp(prefix="douban_zlib_")
        self.stats = {
            'new': 0,
            'matched': 0,
            'uploaded': 0,
            'failed': 0
        }
    
    def setup_jobs(self):
        """设置定时任务。"""
        schedule_time = self.config.config['schedule']['time']
        hour, minute = schedule_time.split(':')
        
        # 添加每日同步任务
        self.scheduler.add_job(
            self.run_sync_task,
            CronTrigger(hour=hour, minute=minute),
            id='daily_sync',
            replace_existing=True
        )
        
        logger.info(f"已设置每日同步任务，执行时间: {schedule_time}")
    
    def start(self):
        """启动调度器。"""
        self.scheduler.start()
        logger.info("调度器已启动")
    
    def stop(self):
        """停止调度器。"""
        self.scheduler.shutdown()
        # 清理临时目录
        try:
            shutil.rmtree(self.temp_dir)
        except Exception as e:
            logger.warning(f"清理临时目录失败: {e}")
        logger.info("调度器已停止")
    
    def run_sync_task(self):
        """执行同步任务。"""
        logger.info("开始执行同步任务")
        start_time = datetime.now()
        
        # 重置统计数据
        self.stats = {'new': 0, 'matched': 0, 'uploaded': 0, 'failed': 0}
        
        try:
            # 1. 爬取豆瓣书单
            books = self.douban_scraper.run()
            
            # 2. 处理每本书
            for book in books:
                self._process_book(book)
            
            # 3. 发送任务报告
            self.lark_service.send_task_report(self.stats)
            
            end_time = datetime.now()
            duration = (end_time - start_time).total_seconds() / 60
            logger.info(f"同步任务完成，耗时: {duration:.2f} 分钟")
            
        except Exception as e:
            logger.error(f"同步任务执行失败: {e}")
            # 尝试发送错误报告
            self.lark_service.send_message(
                "❌ 豆瓣书单同步任务失败",
                f"同步过程中发生错误: {str(e)}\n\n请检查日志获取详细信息。"
            )
    
    def _process_book(self, book):
        """处理单本书籍。"""
        title = book['title']
        author = book['author']
        douban_url = book['douban_url']
        
        logger.info(f"处理书籍: {title} - {author}")
        
        # 1. 添加到数据库
        db_book = self.db.add_book(title, author, douban_url)
        if db_book.status != 'new':
            logger.info(f"书籍已存在于数据库: {title}")
            return
        
        self.stats['new'] += 1
        
        # 2. 查询 Calibre 是否已有此书
        book_ids = self.calibre_service.search_book(title, author)
        if book_ids:
            logger.info(f"书籍已存在于 Calibre: {title}")
            self.db.update_book_status(db_book.id, 'matched')
            self.stats['matched'] += 1
            return
        
        # 3. 从 Z-Library 下载
        try:
            search_result = self.zlibrary_service.search_book(title, author)
            if not search_result:
                logger.warning(f"在 Z-Library 中未找到书籍: {title}")
                self.stats['failed'] += 1
                return
            
            book_id = search_result['id']
            file_path = self.zlibrary_service.download_book(book_id, self.temp_dir)
            if not file_path:
                logger.error(f"下载书籍失败: {title}")
                self.db.update_book_status(db_book.id, 'download_failed')
                self.stats['failed'] += 1
                return
            
            self.db.update_book_status(db_book.id, 'downloaded')
            
            # 4. 上传到 Calibre
            metadata = {'title': title, 'author': author}
            calibre_id = self.calibre_service.upload_book(file_path, metadata)
            if calibre_id:
                logger.info(f"书籍已上传到 Calibre: {title}")
                self.db.update_book_status(db_book.id, 'uploaded')
                self.stats['uploaded'] += 1
            else:
                logger.error(f"上传书籍到 Calibre 失败: {title}")
                self.stats['failed'] += 1
            
            # 清理临时文件
            try:
                if file_path and os.path.exists(file_path):
                    os.remove(file_path)
            except Exception as e:
                logger.warning(f"清理临时文件失败: {e}")
                
        except Exception as e:
            logger.error(f"处理书籍时出错: {title} - {e}")
            self.stats['failed'] += 1
```

### 8. 主程序

**文件**：`main.py`

**职责**：初始化和启动系统。

**实现要点**：
- 解析命令行参数
- 初始化各模块
- 启动调度系统

**示例代码**：

```python
import argparse
import signal
import sys
from pathlib import Path

from config.config_manager import ConfigManager
from db.database import Database
from scrapers.douban_scraper import DoubanScraper
from services.calibre_service import CalibreService
from services.zlibrary_service import ZLibraryService
from services.lark_service import LarkService
from scheduler.task_scheduler import TaskScheduler
from utils.logger import setup_logger, get_logger

def signal_handler(sig, frame):
    """处理信号，优雅退出。"""
    logger = get_logger(__name__)
    logger.info("接收到退出信号，正在停止...")
    if 'scheduler' in globals():
        scheduler.stop()
    sys.exit(0)

def main():
    # 解析命令行参数
    parser = argparse.ArgumentParser(description='豆瓣书单同步与 Calibre 集成自动化')
    parser.add_argument('--config', default='config.yaml', help='配置文件路径')
    parser.add_argument('--run-now', action='store_true', help='立即执行同步任务')
    args = parser.parse_args()
    
    # 设置日志
    logger = setup_logger()
    logger.info("初始化系统...")
    
    try:
        # 初始化配置
        config_path = Path(args.config)
        if not config_path.exists():
            logger.error(f"配置文件不存在: {config_path}")
            sys.exit(1)
        
        config_manager = ConfigManager(config_path)
        
        # 初始化数据库
        db = Database(config_manager.get_database_url())
        db.init_db()
        
        # 初始化服务
        douban_config = config_manager.get_douban_config()
        douban_scraper = DoubanScraper(douban_config['cookie'])
        
        calibre_config = config_manager.config['calibre']
        calibre_service = CalibreService(
            calibre_config['content_server_url'],
            calibre_config['username'],
            calibre_config['password']
        )
        
        zlibrary_config = config_manager.config['zlibrary']
        zlibrary_service = ZLibraryService(
            zlibrary_config['username'],
            zlibrary_config['password'],
            zlibrary_config['format_priority']
        )
        
        lark_config = config_manager.config['lark']
        lark_service = LarkService(lark_config['webhook_url'])
        
        # 初始化调度器
        global scheduler
        scheduler = TaskScheduler(
            config_manager,
            db,
            douban_scraper,
            calibre_service,
            zlibrary_service,
            lark_service
        )
        
        # 设置信号处理
        signal.signal(signal.SIGINT, signal_handler)
        signal.signal(signal.SIGTERM, signal_handler)
        
        # 设置定时任务
        scheduler.setup_jobs()
        
        # 启动调度器
        scheduler.start()
        
        # 如果指定了立即执行，则运行同步任务
        if args.run_now:
            logger.info("立即执行同步任务")
            scheduler.run_sync_task()
        
        logger.info("系统已启动，按 Ctrl+C 停止")
        
        # 保持主线程运行
        while True:
            signal.pause()
            
    except KeyboardInterrupt:
        logger.info("接收到用户中断，正在停止...")
        if 'scheduler' in globals():
            scheduler.stop()
    except Exception as e:
        logger.error(f"系统初始化失败: {e}")
        sys.exit(1)

if __name__ == '__main__':
    main()
```

## 调试与测试技巧

### 1. 单元测试

为每个模块编写单元测试，确保基本功能正确：

```bash
# 运行所有测试
pytest

# 运行特定测试文件
pytest tests/test_douban_scraper.py

# 带覆盖率报告
pytest --cov=. tests/
```

### 2. 模块独立测试

可以单独测试各个模块，便于调试：

```python
# 测试豆瓣爬虫
from scrapers.douban_scraper import DoubanScraper

scraper = DoubanScraper("your_cookie")
books = scraper.run()
print(f"爬取到 {len(books)} 本书")
for book in books[:5]:  # 打印前 5 本
    print(f"{book['title']} - {book['author']}")
```

### 3. 日志分析

使用日志分析工具查看运行日志，定位问题：

```bash
# 查看最近的错误日志
grep ERROR logs/app.log | tail -n 20

# 统计各类日志数量
grep -c "INFO" logs/app.log
grep -c "WARNING" logs/app.log
grep -c "ERROR" logs/app.log
```

### 4. 调试模式运行

使用调试模式运行程序，便于排查问题：

```bash
# 设置环境变量启用调试日志
export DEBUG=1
python main.py --run-now
```

## 部署指南

### 1. 系统要求

- Python 3.8 或更高版本
- Calibre 5.0 或更高版本，并启用 Content Server
- 稳定的网络连接
- 足够的存储空间（视书库大小而定）

### 2. 生产环境部署

1. **准备环境**

   ```bash
   # 创建项目目录
   mkdir -p /opt/douban_zlib
   cd /opt/douban_zlib
   
   # 创建虚拟环境
   python3 -m venv venv
   source venv/bin/activate
   
   # 克隆代码
   git clone <repository-url> .
   
   # 安装依赖
   pip install -r requirements.txt
   ```

2. **配置系统**

   ```bash
   # 复制并编辑配置文件
   cp config.yaml.example config.yaml
   nano config.yaml  # 编辑配置文件
   
   # 初始化数据库
   python -c "from db.database import Database; db = Database('sqlite:///data/douban_books.db'); db.init_db()"
   ```

3. **设置自动启动**

   **Linux (systemd)**:

   创建服务文件 `/etc/systemd/system/douban-zlib.service`：

   ```ini
   [Unit]
   Description=Douban ZLibrary Sync Service
   After=network.target
   
   [Service]
   Type=simple
   User=<your-user>
   WorkingDirectory=/opt/douban_zlib
   ExecStart=/opt/douban_zlib/venv/bin/python /opt/douban_zlib/main.py
   Restart=on-failure
   RestartSec=5
   
   [Install]
   WantedBy=multi-user.target
   ```

   启用服务：

   ```bash
   sudo systemctl enable douban-zlib.service
   sudo systemctl start douban-zlib.service
   ```

   **Windows**:

   创建计划任务，设置开机自启动。

4. **日志轮转**

   创建 `/etc/logrotate.d/douban-zlib` 文件：

   ```
   /opt/douban_zlib/logs/*.log {
       daily
       missingok
       rotate 7
       compress
       delaycompress
       notifempty
       create 0640 <your-user> <your-group>
   }
   ```

### 3. 监控与维护

1. **检查系统状态**

   ```bash
   # 查看服务状态
   sudo systemctl status douban-zlib.service
   
   # 查看日志
   tail -f /opt/douban_zlib/logs/app.log
   ```

2. **手动触发同步**

   ```bash
   # 立即执行同步任务
   cd /opt/douban_zlib
   source venv/bin/activate
   python main.py --run-now
   ```

3. **数据库备份**

   ```bash
   # 备份 SQLite 数据库
   cp /opt/douban_zlib/data/douban_books.db /backup/douban_books_$(date +%Y%m%d).db
   ```

4. **更新系统**

   ```bash
   # 更新代码
   cd /opt/douban_zlib
   git pull
   
   # 更新依赖
   source venv/bin/activate
   pip install -r requirements.txt
   
   # 重启服务
   sudo systemctl restart douban-zlib.service
   ```

## 常见问题解决

### 1. 豆瓣爬虫问题

**问题**：爬虫无法获取数据或登录失败

**解决方案**：
- 检查 Cookie 是否有效，可能需要重新获取
- 检查网站结构是否变化，可能需要更新选择器
- 添加随机延迟，避免被反爬虫机制检测

### 2. Z-Library 下载问题

**问题**：无法从 Z-Library 下载书籍

**解决方案**：
- 检查账号是否有效，可能需要重新登录
- 检查是否达到下载限制，可能需要等待或使用其他账号
- 尝试使用代理服务器，避免 IP 被封锁

### 3. Calibre 连接问题

**问题**：无法连接到 Calibre Content Server

**解决方案**：
- 确认 Calibre Content Server 是否正在运行
- 检查服务器地址、用户名和密码是否正确
- 检查网络连接和防火墙设置

### 4. 数据库问题

**问题**：数据库操作失败或性能下降

**解决方案**：
- 检查数据库连接配置
- 优化索引和查询
- 定期清理历史数据

### 5. 调度问题

**问题**：定时任务未执行

**解决方案**：
- 检查系统时间是否正确
- 确认调度器是否正常运行
- 检查日志中是否有错误信息

## 结语

本开发指南提供了「豆瓣书单同步与 Calibre 集成自动化」项目的详细实施指导。通过遵循本指南，开发人员可以高效地实现各个模块，并将它们集成为一个完整的系统。

在开发过程中，请注意遵循代码规范，编写充分的测试，并保持良好的文档习惯。如有任何问题或建议，请参考项目 README 或联系项目维护者。